<html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
        <style>
            .output{
                position:absolute;
                left:0;
                top:0;
                width:100%;
                height:100%
            }

            .instructions{
                left:25%;
                top:25%;
                width:50%;
                height:50%;
                position:absolute;
                pointer-events: none;
                font-family: Helvetica;
                font-size: 18px;
                text-align:center;
                margin-top:15%;
            }

            .output div{
                position:absolute;
            }

            .output div div.item{
                background-color:rgb(118,131,221);
                display:block;
                border-color:rgb(38,49,124);
                border-style:solid;

                position:absolute;
            }

            .score{
                position:absolute;
                left:5;
                top:5;
            }
            .debug{
                position:absolute;
                left:5;
            }
            body{
                -webkit-tap-highlight-color: rgba(0,0,0,0);
            }
        </style>
        <title>Counter</title>
    </head>
    <body>
        <script>

            /************************************************/
            /* CONSTANTS                                    */
            /************************************************/

            var GAME_STATE_NONE = 0;
            var GAME_STATE_RUNNING = 1;
            var GAME_STATE_PAUSED = 2;
            var GAME_STATE_COMPLETE = 3;

            /************************************************/
            /* VARIABLES                                    */
            /************************************************/

            var options = null;
            var canvas = null;
            var instructions = null;
            var prerenderedBuffers = {};
            var boardWidth = window.innerWidth;
            var boardHeight = window.innerHeight;

            var gameState = null;

            var isDebug = getDebugFromQueryString(window.location.search);

            /************************************************/
            /* META CONTROLLER                              */
            /************************************************/

            // this is available to be easily swapped out by the container with
            // custom logic (WKWebView on iOS, WebView on android)
            var metaController = {
                didComplete:function(opts, message){
                    setSavedOptions(opts);
                    alert(message)
                },
                didLoad:function(){
                    var opts = savedOptions();
                    start(opts)
                }
            };

            function savedOptions(){
                var key = "options";
                var options = null;
                try{
                    options = JSON.parse(localStorage.getItem(key))
                }catch(err){
                }
                return options
            }

            function setSavedOptions(options){
                var key = "options";
                localStorage.setItem(key, JSON.stringify( options ) )
            }

            function didLoadHandler(){
                metaController.didLoad()
            }

            /************************************************/
            /* Query String                                 */
            /************************************************/

            function getLevelFromQueryString(queryString){
                var level = new Number(getValueFromQueryString("level",queryString));
                return level > 0 ? level : 1;
            }

            function getDebugFromQueryString(queryString){
                return getValueFromQueryString("debug", queryString) == "true";
            }

            function getValueFromQueryString(key,queryString){

                if(queryString[0] == "?"){
                    queryString = queryString.substring(1)
                }

                var params = queryString.split("&");

                var value = null;

                for ( var index = 0; index < params.length; index++){
                    var pieces = params[index].split("=")
                    if(pieces[0] == key && pieces[1] != null && pieces[1].length > 0){
                        value = pieces[1]
                    }
                }

                return value;

            }

            /************************************************/
            /* DOM SETUP                                    */
            /************************************************/

            function setupCanvas(isDebug){

                canvas = document.createElement('div');
                canvas.className = "output";

                document.body.appendChild(canvas);

                new ClickListener(canvas,'space',didTap);

            }

            function setupInstructions(){

                if(isDebug){
                    boardHeight = Math.floor(window.innerHeight*0.9);
                }

                instructions = document.createElement('div');
                instructions.className = "instructions";

                instructions.style.display = "none";

                instructions.innerText = "Tap the screen when the counter skips."

                document.body.appendChild(instructions);

            }

            /************************************************/
            /* START/STOP                                   */
            /************************************************/

            function start(opts){
                options = opts;
                if(options == null){
                  options = {};
                }
                if(isDebug){
                  options.level = getLevelFromQueryString(window.location.search)
                }
                gameState = getNewGameState(options);
                startRendering()
            }

            function startRendering(){

                gameState.state = GAME_STATE_RUNNING;

                gameState.lastTimestamp = (new Date()).getTime();

                window.requestAnimationFrame(render);
            }

            function pauseRendering(){
                gameState.state = GAME_STATE_PAUSED;
            }

            function stop(){
                gameState.state = GAME_STATE_COMPLETE;
            }

            function reset(){
                options = {}
                gameState = getNewGameState(options);
            }

            function didComplete(state, controller){
              var instructionsSeen = state.needsInstructions ? "0" : "1";
              var level = state.level;
              if(state.ticks > 60000){
                level = state.level + 1
              }
              var options = {
                "instructionsSeen":instructionsSeen,
                "level":level,
              }
              controller.didComplete(options,"All Done");
            }

            /************************************************/
            /* GAME STATE                                   */
            /************************************************/

            var countsByLevel = [0,12,16,20,12,16,20];

            var sideCountsByLevel = [0,4,5,6,4,5,6];

            var clocksByLevel = [0,1,1,1,2,2,2];

            var tickIndexesByLevel = [null,
              [0,1,2,3,7,11,15,14,13,12,8,4],
              [0,1,2,3,4,9,14,19,24,23,22,21,20,15,10,5],
              [0,1,2,3,4,5,11,17,23,29,35,34,33,32,31,30,24,18,12,6],
              [0,1,2,3,7,11,15,14,13,12,8,4],
              [0,1,2,3,4,9,14,19,24,23,22,21,20,15,10,5],
              [0,1,2,3,4,5,11,17,23,29,35,34,33,32,31,30,25,20,15,10,5],
            ];

            var maxLevel = 6

            function getNewGameState(options){

                var needsInstructions = options.instructionsSeen != "1";
                var level = parseInt( options.level );
                if(isNaN(level) || level == null || level < 1 || level > maxLevel){
                  level = 1
                }

                var clockTotal = clocksByLevel[level];

                var clocks = [];

                while(clockTotal > 0){
                  clocks.push(getNewClockState(level))
                  clockTotal--;
                }

                return {
                    "state":GAME_STATE_NONE,
                    "level":level,
                    "correctCount":0,
                    "lastTimestamp":(new Date()).getTime(),
                    "internalTicks":0,
                    "ticks":0,
                    "ticksToStartSpeed":0,
                    "ticksToFullSpeed":60000,
                    "needsInstructions":needsInstructions,
                    "clocks":clocks,
                };
            }

            function getNewClockState(level){

              var count = countsByLevel[level];
              var tickIndexes = tickIndexesByLevel[level];
              var sideCount = sideCountsByLevel[level];

              var states = []

              for( var i = 0; i < count; i++){
                states.push(0)
              }

              return {
                  "states":states,
                  "tickIndexes":tickIndexes,
                  "currentPosition":0,
                  "tickInterval":1000,
                  "count":count,
                  "sideCount":sideCount,
                  "positionOffset":0,
                  "lastSkipPosition":-1,
                  "lastTapPosition":-1,
              }
            }

            function updateState(state){
                state = incrementTicks(state)
                state = incrementClocks(state,shouldIncrementOffset)
                return state
            }

            function incrementTicks(state){

              var timestamp = (new Date()).getTime();

              var t = timestamp - state.lastTimestamp; //in milleseconds

              var speed = 0.8; //average speed
              var startingSpeed = 0.8;
              var fullSpeed = 1.4;

              if(state.internalTicks > state.ticksToStartSpeed){
                  if(state.internalTicks > state.ticksToFullSpeed){
                      speed = fullSpeed;
                  }else{
                      speed = ( fullSpeed - startingSpeed ) * (state.internalTicks - state.ticksToStartSpeed) / (state.ticksToFullSpeed - state.ticksToStartSpeed)  + startingSpeed;
                  }
              }

              state.internalTicks = state.internalTicks + t*speed;

              state.ticks = state.internalTicks;

              state.lastTimestamp = (new Date()).getTime();

              return state

            }

            function shouldIncrementOffset(state){
                return Math.random() > 0.8;
            }

            function incrementClocks(state, randFunc){

                for( var i = 0; i < state.clocks.length; i++ ){

                    var clock = state.clocks[i];

                    var nextPosition = Math.floor(state.ticks/clock.tickInterval) + clock.positionOffset ;

                    if ( clock.currentPosition != nextPosition ) {

                        if ( 0 <= clock.lastSkipPosition ) {
                            clock.states[(clock.lastSkipPosition - 1) %clock.count] = 2;
                            state.state = GAME_STATE_COMPLETE
                        }

                        clock.states[nextPosition%clock.count] = 0;

                        if(randFunc(state)){
                            clock.positionOffset++;
                            nextPosition++;
                            clock.lastSkipPosition = nextPosition;
                            clock.states[nextPosition%clock.count] = 0;
                        }

                        clock.currentPosition = nextPosition;

                    }


                }
                return state;

            }

            function updateStateWithTap(state){

                var didFindTappableClock = false;

                for( var i = 0; i < state.clocks.length; i++ ){

                    var clock = state.clocks[i];

                    if ( clock.currentPosition == clock.lastSkipPosition ) {

                        clock.lastSkipPosition = -1;

                        didFindTappableClock = true;
                        state.correctCount++;
                        if(state.correctCount > 2){
                          state.needsInstructions = false;
                        }
                        clock.states[(clock.currentPosition - 1) %clock.count] = 1;
                    }

                }

                if(!didFindTappableClock){
                    clock.states[clock.currentPosition %clock.count] = 2;
                    gameState.state = GAME_STATE_COMPLETE
                }

                return state;

            }

            function clear(){
                canvas.innerText = "";
            }

            /************************************************/
            /* EVENT LISTENING                              */
            /************************************************/

            function didTap(listener){
                if(gameState){
                    gameState = updateStateWithTap(gameState);
                }
            }

            function ClickListener(el, letter, completion) {
                this.completion = completion;
                this.element = el;
                this.letter = letter;
                this.element.addEventListener(this.startName, this, false);
                window.addEventListener(this.keydownName, this, false);
            }

            ClickListener.prototype = {

                keydownName:'keydown',
                keyupName:'keyup',
                startName:(('ontouchstart' in document.documentElement)?'touchstart':'mousedown'),
                leaveName:(('ontouchstart' in document.documentElement)?'touchleave':'mouseout'),
                endName:(('ontouchstart' in document.documentElement)?'touchend':'mouseup'),

                isTracking:false,

                handleEvent: function(e) {
                    switch(e.type) {
                        case this.keydownName: this.onKeyStart(e); break;
                        case this.startName: this.onStart(e); break;
                        case this.keyupName: this.onKeyEnd(e); break;
                        case this.leaveName: this.onLeave(e); break;
                        case this.endName: this.onEnd(e); break;
                    }
                },

                onStart: function(e) {

                    e.preventDefault();
                    this.moved = false;

                    this.theTarget = document.elementFromPoint(e.target.clientX, e.target.clientY);
                    if(this.theTarget.nodeType == 3) {
                        this.theTarget = theTarget.parentNode;
                    }

                    this.element.addEventListener(this.leaveName, this, false);
                    this.element.addEventListener(this.endName, this, false);
                },

                onKeyStart: function(e) {
                    var isUnmodified = !e.metaKey && !e.ctrlKey  && !e.altKey;
                    if( isUnmodified ){
                        e.preventDefault();
                        var key = this.stringFromKeyCode(e.keyCode ? e.keyCode : e.which)
                        if(key == this.letter && !this.isTracking){
                            this.isTracking = true;
                            window.addEventListener(this.keyupName, this, false);
                        }
                    }

                },

                onKeyEnd: function(e) {
                    var isUnmodified = !e.metaKey && !e.ctrlKey  && !e.altKey;
                    if( isUnmodified ){
                        e.preventDefault();
                    }
                    if( this.isTracking ){
                        this.isTracking = false;
                        window.removeEventListener(this.keyupName, this, false);
                        if( isUnmodified ){
                            this.completion(this);
                        }
                    }
                },

                onLeave: function(e) {
                    this.element.removeEventListener(this.leaveName, this, false);
                    this.element.removeEventListener(this.endName, this, false);
                    this.theTarget = undefined;
                },

                onEnd: function(e) {
                    this.element.removeEventListener(this.leaveName, this, false);
                    this.element.removeEventListener(this.endName, this, false);

                    this.completion(this);

                    this.theTarget = undefined;
                },

                stringFromKeyCode: function(keyCode) {
                    if ( 65 <= keyCode && keyCode <= 90 ) {
                        return String.fromCharCode(keyCode).toLowerCase();
                    } else if( keyCode == 8 || keyCode == 46 ) {
                        return "del";
                    } else if( keyCode == 32 ){
                        return "space";
                    } else {
                        return "NOT FOUND"
                    }
                }

            };


            /************************************************/
            /* RENDERING                                    */
            /************************************************/

            function render(){

                if( gameState && gameState.state == GAME_STATE_RUNNING) {
                    //we might call game over here
                    gameState = updateState(gameState);
                }

                if( gameState && gameState.state == GAME_STATE_RUNNING) {

                    drawState(gameState);

                    window.requestAnimationFrame(render);

                }else{

                    clear();
                    if( gameState && gameState.state == GAME_STATE_COMPLETE) {
                        //draw the final state of the game
                        drawState(gameState);
                        setTimeout( function(){ didComplete(gameState, metaController) }, 3000);

                    }

                }

            }

            /************************************************/
            /* DRAWING                                      */
            /************************************************/

            function drawState(state){

                instructions.style.display = state.needsInstructions ? "block" : "none"

                if(canvas.childNodes.length != state.clocks.length){
                    while(canvas.childNodes.length < state.clocks.length){
                        canvas.appendChild(document.createElement('div'))
                    }
                    while(canvas.childNodes.length > state.clocks.length){
                        canvas.removeChild(canvas.childNodes[canvas.childNodes.length - 1])
                    }
                }

                var clockColumns = state.clocks.length;
                var clockRows = 1;

                var clockWidth = (100*(1/clockColumns));
                var clockHeight = (100*(1/clockRows));

                for( var i = 0; i < state.clocks.length; i++ ){

                    var clock = state.clocks[i];

                    var clockDiv = canvas.childNodes[i];

                    clockDiv.style.width = clockWidth+"%";
                    clockDiv.style.height = clockHeight+"%";
                    clockDiv.style.left = (i*clockWidth)+"%";

                    var itemColumns = clock.sideCount;
                    var itemRows = clock.sideCount;

                    var columnWidth = 100*(1/itemColumns);
                    var rowHeight = 100*(1/itemRows);

                    var itemWidth = columnWidth*0.90;
                    var itemHeight = rowHeight*0.90;

                    var borderRadius = boardWidth*Math.min(itemWidth,itemHeight)*0.25/100;
                    var borderWidth = boardWidth*Math.min(itemWidth,itemHeight)*0.05/100;

                    var itemIndex = clock.currentPosition%clock.count;
                    var itemXOffset = columnWidth*0.05;
                    var itemYOffset = rowHeight*0.05;

                    while(clockDiv.childNodes.length < clock.count){
                        clockDiv.appendChild(document.createElement('div'));
                    }
                    while(clockDiv.childNodes.length > clock.count){
                        clockDiv.removeChild(clockDiv.childNodes[clockDiv.childNodes.length - 1])
                    }
                    for( var p = 0; p < clock.count; p++ ){
                        var itemDiv = clockDiv.childNodes[p];
                        itemDiv.className = "item";

                        var j = clock.tickIndexes[p];

                        itemDiv.style.left = (itemXOffset + (j%itemColumns)*columnWidth)+"%";
                        itemDiv.style.top = (itemYOffset + Math.floor(j/itemColumns)*rowHeight)+"%";
                        itemDiv.style.width = itemWidth+"%";
                        itemDiv.style.height = itemHeight+"%";

                        itemDiv.style.borderWidth = borderWidth+"px";
                        itemDiv.style.borderRadius = borderRadius+"px";
                        itemDiv.style.margin = (-1*borderWidth)+"px";


                        if(p == itemIndex && state.state != GAME_STATE_COMPLETE){
                            itemDiv.style.backgroundColor = "#FFD700";
                        }else if(clock.states[p] == 2){
                           itemDiv.style.backgroundColor = "#FF0000";
                        }else if(clock.states[p] == 1){
                            itemDiv.style.backgroundColor = "#00FF00";
                        }else{
                            itemDiv.style.backgroundColor = null;
                        }
                    }

                }

            }

            setupCanvas(isDebug);

            setupInstructions();

            window.addEventListener("load", didLoadHandler,false)

        </script>
    </body>
</html>
