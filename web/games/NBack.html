<html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
        <style>
            .canvas{
                position:absolute;
                left:0;
                top:0;
            }
            .score{
                position:absolute;
                left:5;
                top:5;
            }
            .debug{
                position:absolute;
                left:5;
            }
            body{
                -webkit-tap-highlight-color: rgba(0,0,0,0);
            }
        </style>
        <title>NBack</title>
    </head>
    <body>
        <script>

            /************************************************/
            /* CONSTANTS                                    */
            /************************************************/

            var GAME_STATE_NONE = 0;
            var GAME_STATE_RUNNING = 1;
            var GAME_STATE_COMPLETE = 2;

            var ITEM_STATE_NONE = 0;
            var ITEM_STATE_ACTIVE = 1;
            var ITEM_STATE_CORRECT = 2;
            var ITEM_STATE_INCORRECT = 3;

            var TICKS_PER_ITEM = 1400;

            var N_BY_LEVEL = [0,
              1,1,1,
              2,2,2,
              3,3,3,
              4,4,4,
              5,5,5,
              6,6,6,
              7,7,7,
              8,8,8]
            var SPEED_BY_LEVEL = [0,
              0.8,1.0,1.2,
              0.8,1.0,1.2,
              0.8,1.0,1.2,
              0.8,1.0,1.2,
              0.8,1.0,1.2,
              0.8,1.0,1.2,
              0.8,1.0,1.2,
              0.8,1.0,1.2]
            var TOTAL_BY_LEVEL = [0,
              20,24,28,
              20,24,28,
              20,24,28,
              20,24,28,
              20,24,28,
              20,24,28,
              20,24,28,
              20,24,28]

            /************************************************/
            /* VARIABLES                                    */
            /************************************************/

            var options = null;
            var canvas = null;
            var scoreLabel = null;
            var prerenderedBuffers = {};
            var boardWidth = window.innerWidth;
            var boardHeight = window.innerHeight;

            var gameState = null;

            var isDebug = getDebugFromQueryString(window.location.search);

            /************************************************/
            /* START                                        */
            /************************************************/

            function start(opts){
                options = opts;

                if(options == null || options["level"] == null){
                    options = {"level":1,"failCount":0}
                }

                if(getDebugFromQueryString(window.location.search)){
                    options["level"] = getLevelFromQueryString( window.location.search );
                }

                gameState = getNewGameState(options);
                startRendering()
            }

            /************************************************/
            /* META CONTROLLER                              */
            /************************************************/

            // this is available to be easily swapped out by the container with
            // custom logic (WKWebView on iOS, WebView on android)
            var metaController = {
                didComplete:function(opts, message){
                    setSavedOptions(opts);
                    alert(message)
                },
                didLoad:function(){
                    var opts = savedOptions();
                    start(opts)
                }
            };

            function didLoadHandler(){
                metaController.didLoad()
            }

            /************************************************/
            /* Query String                                 */
            /************************************************/

            function getLevelFromQueryString(queryString){
                var level = new Number(getValueFromQueryString("level",queryString));
                return level > 0 ? level : 1;
            }

            function getDebugFromQueryString(queryString){
                return getValueFromQueryString("debug", queryString) == "true";
            }

            function getValueFromQueryString(key,queryString){

                if(queryString[0] == "?"){
                    queryString = queryString.substring(1)
                }

                var params = queryString.split("&");

                var value = null;

                for ( var index = 0; index < params.length; index++){
                    var pieces = params[index].split("=")
                    if(pieces[0] == key && pieces[1] != null && pieces[1].length > 0){
                        value = pieces[1]
                    }
                }

                return value;

            }

            /************************************************/
            /* DOM SETUP                                    */
            /************************************************/

            function updateScoreLabel(state){
                var score = state.currentIndex ;
                scoreLabel.innerText = "count: "+score + " highscore: "+state.highscore;
            }

            function setupCanvas(isDebug){

                if(isDebug){
                    boardHeight = Math.floor(window.innerHeight*0.9);
                }

                canvas = document.createElement('canvas');
                canvas.className = "canvas";

                canvas.width = boardWidth;
                canvas.height = boardHeight;

                document.body.appendChild(canvas);


                scoreLabel = document.createElement('div');
                scoreLabel.className = "score";

                scoreLabel.innerText = "count: - highscore: - ";
                document.body.appendChild(scoreLabel);

            }


            /************************************************/
            /* EVENT HANDLING                               */
            /************************************************/

            function didInput(event){
              gameState.lastMatch = hashForCurrentIndexes(gameState)
              if(!userGaveCorrectInput(gameState)){
                  gameState.itemStates[gameState.currentIndex] = ITEM_STATE_INCORRECT;
                  gameState.itemStates[gameState.currentIndex + gameState.n] = ITEM_STATE_INCORRECT;
                  gameState.state = GAME_STATE_COMPLETE;
              }else{
                gameState.itemStates[gameState.currentIndex] = ITEM_STATE_CORRECT;
                gameState.itemStates[gameState.currentIndex + gameState.n] = ITEM_STATE_CORRECT;
              }
            }

            function startListeningForEvents(){

                new ClickListener();

                canvas.addEventListener("click",didInput);
            }

            function ClickListener() {
                window.addEventListener(this.keydownName, this, false);
            }

            ClickListener.prototype = {

                keydownName:'keydown',
                keyupName:'keyup',

                handleEvent: function(e) {
                    switch(e.type) {
                        case this.keydownName: this.onKeyStart(e); break;
                        case this.keyupName: this.onKeyEnd(e); break;
                    }
                },

                onKeyStart: function(e) {
                    var isUnmodified = !e.metaKey && !e.ctrlKey  && !e.altKey;
                    if( isUnmodified ){
                        e.preventDefault();
                        var key = this.stringFromKeyCode(e.keyCode ? e.keyCode : e.which)
                        window.addEventListener(this.keyupName, this, false);
                    }

                },

                onKeyEnd: function(e) {
                    var isUnmodified = !e.metaKey && !e.ctrlKey  && !e.altKey;
                    if( isUnmodified ){
                        e.preventDefault();
                    }
                    window.removeEventListener(this.keyupName, this, false);
                    if( isUnmodified ){
                        didInput(e);
                    }
                },

                stringFromKeyCode: function(keyCode) {
                    if ( 65 <= keyCode && keyCode <= 90 ) {
                        return String.fromCharCode(keyCode).toLowerCase();
                    } else if( keyCode == 8 || keyCode == 46 ) {
                        return "del";
                    } else if( keyCode == 32 ){
                        return "space";
                    } else {
                        return "NOT FOUND"
                    }
                }

            };

            /************************************************/
            /* START/STOP                                   */
            /************************************************/

            function startRendering(){

                gameState.state = GAME_STATE_RUNNING;

                gameState.lastTimestamp = (new Date()).getTime();

                startListeningForEvents();

                window.requestAnimationFrame(render);
            }

            function didComplete(state, metaController, options){

                var level = gameState.level;
                var failCount = gameState.failCount;
                var highscore = highscoreForLevel(level, options)

                var score = gameState.currentIndex;

                if(score > highscore){
                    setHighscoreForLevel(level, options, score)
                }

                var message = "";

                if (score >= gameState.itemsToNextLevel){

                    failCount = 0;
                    level++
                    message = "(nice work) level up : "+level

                }else{

                    failCount++;

                    if(failCount == 2){
                      failCount = 0;
                      level = Math.max(level - 1, 1);
                      message = "(no worries) level down : "+level
                    }else{
                      message = "(no problem)";
                    }

                }

                options["failCount"] = failCount;

                options["level"] = level;

                metaController.didComplete(options, message)

            }


            /************************************************/
            /* RENDERING                                    */
            /************************************************/

            function render(){

                if( gameState && gameState.state == GAME_STATE_RUNNING ) {
                    //we might call game over here
                    gameState = updateState(gameState);

                }

                if( gameState ) {

                  drawState(gameState);

                  updateScoreLabel(gameState);

                  if( gameState.state == GAME_STATE_RUNNING) {

                    window.requestAnimationFrame(render);
                  } else if( gameState.state == GAME_STATE_COMPLETE) {

                    setTimeout( function(){ didComplete(gameState, metaController, options) }, 1000);
                  }

                }

            }

            /************************************************/
            /* GAME STATE                                   */
            /************************************************/

            function getNewGameState(options){

                var level = options["level"];

                var failCount = options["failCount"];

                var n = N_BY_LEVEL[level];

                var speed = SPEED_BY_LEVEL[level];

                var total = TOTAL_BY_LEVEL[level];

                var boardCount = 2 + n;

                var highscore = highscoreForLevel(level, options);

                var items = [];

                var itemStates = [];

                for(var i = 0; i < total + n; i++){
                    items.push(getRandomSymbol());
                    itemStates.push(ITEM_STATE_NONE);
                }
                itemStates[0] = ITEM_STATE_ACTIVE;
                itemStates[n] = ITEM_STATE_ACTIVE;

                return {
                    "speed":speed,
                    "n":n,
                    "failCount":failCount,
                    "state":GAME_STATE_NONE,
                    "ticks":(n)*TICKS_PER_ITEM,
                    "level":level,
                    "internalTicks":(n)*TICKS_PER_ITEM,
                    "lastTimestamp":0,
                    "currentIndex":0,
                    "indexOffset":boardCount - 1,
                    "items":items,
                    "itemStates":itemStates,
                    "maxItemCount":boardCount + 1,
                    "pixelsPerTick":boardWidth/(TICKS_PER_ITEM*(boardCount)),
                    "lastMatch":null,
                    "ticksToStartCover":TICKS_PER_ITEM*(boardCount + 1),
                    "ticksToFullCover":TICKS_PER_ITEM*(boardCount + 5),
                    "itemsToNextLevel":total,
                    "highscore":highscore
                };
            }

            //returns
            function incrementTicks(state){

                if(state.state == GAME_STATE_COMPLETE){
                  return
                }

                var timestamp = (new Date()).getTime();

                var t = timestamp - state.lastTimestamp; //in milleseconds

                var speed = state["speed"]; //average speed

                state.internalTicks = state.internalTicks + t*speed;

                state.lastTimestamp = (new Date()).getTime();

                var partialTicks = state.internalTicks%TICKS_PER_ITEM;
                var ticks = state.internalTicks - partialTicks

                var stillRatio = 0.6
                if(partialTicks > stillRatio*TICKS_PER_ITEM){
                    ticks = ticks + (partialTicks - stillRatio*TICKS_PER_ITEM)/(1 - stillRatio)
                }

                state.ticks = ticks ;

            }

            function updateState(state){

                incrementTicks(state);

                var tickIndex = state.ticks/TICKS_PER_ITEM;

                if( tickIndex - state.indexOffset > state.currentIndex + 1 )
                {
                    if(!userGaveCorrectInput(state)){
                        state.itemStates[state.currentIndex] = ITEM_STATE_INCORRECT;
                        state.itemStates[state.currentIndex + state.n] = ITEM_STATE_INCORRECT;

                        var endTicks = (state.currentIndex + state.indexOffset + 1)*TICKS_PER_ITEM
                        state.internalTicks = endTicks
                        state.ticks = endTicks

                        state.state = GAME_STATE_COMPLETE;
                        return state;
                    }

                    var firstItemState = state.itemStates[state.currentIndex];
                    var secondItemState = state.itemStates[state.currentIndex + state.n];

                    if(firstItemState == ITEM_STATE_ACTIVE){
                      firstItemState = ITEM_STATE_NONE;
                    }
                    if(secondItemState == ITEM_STATE_ACTIVE){
                      secondItemState = ITEM_STATE_NONE;
                    }

                    state.itemStates[state.currentIndex] = firstItemState;
                    state.itemStates[state.currentIndex + state.n] = secondItemState;

                    state.currentIndex = state.currentIndex+1;

                    if(state.itemsToNextLevel <= state.currentIndex){
                      state.state = GAME_STATE_COMPLETE;
                      var endTicks = (state.itemsToNextLevel + state.indexOffset)*TICKS_PER_ITEM
                      state.internalTicks = endTicks
                      state.ticks = endTicks
                      return state;
                    }

                    state.itemStates[state.currentIndex] = ITEM_STATE_ACTIVE;
                    state.itemStates[state.currentIndex + state.n] = ITEM_STATE_ACTIVE;

                }

                return state;

            }

            function userGaveCorrectInput(state){
                //if we have a match, then the user should have indicated
                var matches = state.items[state.currentIndex] == state.items[state.currentIndex + state.n];

                var hash = hashForCurrentIndexes( state )

                //user must provide feedback on either a match or a non match
                if(matches){
                    return state.lastMatch == hash;
                }else{
                    return state.lastMatch != hash;
                }

            }

            function getNextSymbol(state, randFunc){

                if(Math.random() < 0.2){//one tenth of the time, enforce a match
                    console.log("enforcing match on "+ state.items[state.items.length - state.n])
                    return state.items[state.items.length - n]
                }else{
                    return randFunc()
                }

            }

            function getRandomSymbol(){
                var symbols = ["A","B","C","D"];
                var index = Math.floor(Math.random()*symbols.length)
                return symbols[index]
            }

            function clear(){
                var ctx = canvas.getContext('2d');
                ctx.clearRect(0,0,boardWidth,boardHeight); // clear canvas
            }

            function highscoreForLevel(level, options){
                var key = "highscore-"+level;
                var val = options[key] ;
                if(isNaN(val)){
                    return 0
                }else{
                    return val
                }
            }

            function setHighscoreForLevel(level, options, score){
                var key = "highscore-"+level;
                options[key] = score;
            }

            function savedOptions(){
                var key = "nback-options";
                var options = null;
                try{
                    options = JSON.parse(localStorage.getItem(key))
                }catch(err){
                }
                return options
            }

            function setSavedOptions(options){
                var key = "options";
                localStorage.setItem(key, JSON.stringify( options ) )
            }

            function hashForCurrentIndexes(state){
                return (gameState.currentIndex) + " - " + (gameState.currentIndex + gameState.n)
            }

            /************************************************/
            /* DRAWING                                      */
            /************************************************/

            function drawState(state){

                var ctx = canvas.getContext('2d');

                ctx['prerenderedBuffers'] = prerenderedBuffers;

                ctx.clearRect(0,0,boardWidth,boardHeight); // clear canvas

                var y = Math.floor(boardHeight /4);
                var height = Math.floor(boardHeight /2);
                var xOffset = boardWidth /(state.maxItemCount - 1)
                var width = Math.floor(xOffset*(1 - 1/(state.maxItemCount-1)));

                var xPositions = [];

                for(var i = 0; i < state.items.length; i++){
                    var item = state.items[i];
                    var itemState = state.itemStates[i];
                    var xPosition = boardWidth - state.ticks*state.pixelsPerTick + i * xOffset;
                    xPositions.push(xPosition);

                    var x = xPosition+ (xOffset - width)/2.0
                    drawMemoryElement(ctx, item , x , y, width, height, itemState);
                }

                if(state.state == GAME_STATE_RUNNING){

                  var visibleMargin = Math.floor(boardHeight*0.10);
                  var coverWidth = 0;
                  if(state.ticks > state.ticksToStartCover){
                      var fullCoverWidth = (state.n + 1)*xOffset;
                      if(state.ticks > state.ticksToFullCover){
                          coverWidth = fullCoverWidth;
                      }else{
                          coverWidth = fullCoverWidth*( ( state.ticks - state.ticksToStartCover ) / (state.ticksToFullCover - state.ticksToStartCover ) );
                      }
                  }
                  if(coverWidth > 0){
                    drawCover(ctx, 0, y + visibleMargin, coverWidth,height - visibleMargin*2);
                  }
                }

            }

            function drawCover(ctx, x,y,width, height ){
                ctx.fillStyle = 'rgb(128,128,255)';
                ctx.strokeStyle = 'rgba(64,64,255,1.0)';

                ctx.lineWidth =4.0;

                ctx.beginPath();
                ctx.moveTo(x,y);
                ctx.lineTo(x,y+height);
                ctx.lineTo(x+width,y+ height);
                ctx.lineTo(x+width,y);
                ctx.lineTo(x,y);
                ctx.closePath();

                ctx.fill()
                ctx.stroke()


            }


            function drawMemoryElement(ctx, symbol, x,y,width,height, state){

                var key = symbol+"-"+width+"-"+height+"-"+state;

                var image = ctx['prerenderedBuffers'][key];

                if( image == null){
                    image = prerenderMemoryElement(symbol,width,height,state);
                    ctx['prerenderedBuffers'][key] = image;
                }

                ctx.drawImage(image, x, y);

            }

            function prerenderMemoryElement(symbol,width,height,state){
                var m_canvas = document.createElement('canvas');
                m_canvas.width = width;
                m_canvas.height = height;
                var m_context = m_canvas.getContext('2d');

                if(state == ITEM_STATE_NONE){
                  m_context.fillStyle = 'rgba(255,255,255,1)';
                }else if(state == ITEM_STATE_ACTIVE){
                  m_context.fillStyle = 'rgba(255,235,128,1)';
                }else if(state == ITEM_STATE_CORRECT){
                  m_context.fillStyle = 'rgba(128,255,128,1)';
                }else if(state == ITEM_STATE_INCORRECT){
                  m_context.fillStyle = 'rgba(255,128,128,1)';
                }

                m_context.strokeStyle = 'rgba(128,128,255,1.0)';

                m_context.beginPath();
                m_context.lineWidth = Math.floor(0.10*width);
                m_context.moveTo(0,0);
                m_context.lineTo(0,height);
                m_context.lineTo(width,height);
                m_context.lineTo(width,0);
                m_context.lineTo(0,0);
                m_context.closePath();

                //stroke then fill
                m_context.fill()
                m_context.stroke()

                var fontHeight = 40;

                m_context.fillStyle = 'rgba(0,0,0,1)';
                m_context.font = 'italic 40pt Calibri, sans-serif';
                m_context.fillText(symbol, (width-fontHeight)/2.0, (height-fontHeight)/2.0+fontHeight);
                return m_canvas;
            }



            setupCanvas(isDebug);

            window.addEventListener("load", didLoadHandler,false)

        </script>
    </body>
</html>
