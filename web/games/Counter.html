<html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
        <style>
            body {
              margin:0px;
            }
            .output{
                position:absolute;
                left:0;
                top:0;
                width:100%;
                height:100%
            }

            .output div{
                position:absolute;
            }

            .output div div.item{
                background-color:rgb(118,131,221);
                display:block;

                position:absolute;
            }

            .score{
                position:absolute;
                left:5;
                top:5;
            }
            .debug{
                position:absolute;
                left:5;
            }
            body{
                -webkit-tap-highlight-color: rgba(0,0,0,0);
            }
        </style>
        <title>Counter</title>
    </head>
    <body>
        <script>

            /************************************************/
            /* CONSTANTS                                    */
            /************************************************/

            var GAME_STATE_NONE = 0;
            var GAME_STATE_RUNNING = 1;
            var GAME_STATE_COMPLETE = 2;

            /************************************************/
            /* VARIABLES                                    */
            /************************************************/

            var options = null;
            var canvas = null;
            var prerenderedBuffers = {};
            var boardWidth = window.innerWidth;
            var boardHeight = window.innerHeight;

            var gameState = null;

            var isDebug = getDebugFromQueryString(window.location.search);
            var noautostart = getNoAutoStartFromQueryString(window.location.search);

            /************************************************/
            /* META CONTROLLER                              */
            /************************************************/

            // this is available to be easily swapped out by the container with
            // custom logic (WKWebView on iOS, WebView on android)
            var metaController = {
                didComplete:function(opts, message){
                    setSavedOptions(opts);
                    alert(message)
                },
                didLoad:function(){
                    var opts = savedOptions();
                    start(opts)
                }
            };

            function savedOptions(){
                var key = "counter-options";
                var options = null;
                try{
                    options = JSON.parse(localStorage.getItem(key))
                }catch(err){
                }
                return options
            }

            function setSavedOptions(options){
                var key = "options";
                localStorage.setItem(key, JSON.stringify( options ) )
            }

            function didLoadHandler(){
              if(!noautostart){
                metaController.didLoad()
              }
            }

            /************************************************/
            /* Query String                                 */
            /************************************************/

            function getLevelFromQueryString(queryString){
                var level = new Number(getValueFromQueryString("level",queryString));
                return level > 0 ? level : 1;
            }

            function getDebugFromQueryString(queryString){
                return getValueFromQueryString("debug", queryString) == "true";
            }

            function getNoAutoStartFromQueryString(queryString){
                return getValueFromQueryString("noautostart", queryString) == "true";
            }

            function getValueFromQueryString(key,queryString){

                if(queryString[0] == "?"){
                    queryString = queryString.substring(1)
                }

                var params = queryString.split("&");

                var value = null;

                for ( var index = 0; index < params.length; index++){
                    var pieces = params[index].split("=")
                    if(pieces[0] == key && pieces[1] != null && pieces[1].length > 0){
                        value = pieces[1]
                    }
                }

                return value;

            }

            /************************************************/
            /* DOM SETUP                                    */
            /************************************************/

            function setupCanvas(isDebug){

                canvas = document.createElement('div');
                canvas.className = "output";

                document.body.appendChild(canvas);

                new ClickListener(canvas,'space',didTap);

            }

            /************************************************/
            /* START/STOP                                   */
            /************************************************/

            function start(opts){
                options = opts;
                if(options == null){
                  options = {"level":1,"failCount":0};
                }
                if(options.predefinedGameState){

                  gameState = options.predefinedGameState;

                }else{

                  if(isDebug){
                    options.level = getLevelFromQueryString(window.location.search)
                  }

                  gameState = getNewGameState(options);

                }
                startRendering()
            }

            function startRendering(){

                gameState.state = GAME_STATE_RUNNING;

                gameState.lastTimestamp = (new Date()).getTime();

                window.requestAnimationFrame(render);
            }

            function hasCompleteAllClocks(state){
              var result = true;
              for( var i = 0; i < state.clocks.length; i++ ){

                var clock = state.clocks[i];
                if(!clock.isComplete){
                  result = false;
                }
              }
              return result;
            }

            function didComplete(state, controller){
              var level = state.level;
              var failCount = state.failCount;
              var message = "(no problem)"
              if ( hasCompleteAllClocks(state) ) {
                level = level + 1;
                message = "(nice work) level up : "+level
              } else {
                failCount = failCount + 1;
                if(failCount == 2){
                  failCount = 0;
                  level = Math.max(level - 1, 1);
                  message = "(no problem) level down : "+level
                }
              }
              var options = {
                "level":level,
                "failCount":failCount,
              }
              controller.didComplete(options,message);
            }

            /************************************************/
            /* GAME STATE                                   */
            /************************************************/

            var countsByLevel = [0,12,16,20,12,16,20,12,16,20];

            var clocksByLevel = [0,1,1,1,2,2,2,3,3,3];

            var maxLevel = 9

            function getNewGameState(options){

                var level = parseInt( options.level );
                if(isNaN(level) || level == null || level < 1){
                  level = 1
                }
                if( level > maxLevel){
                  level = maxLevel;
                }

                var failCount = parseInt( options.failCount );
                if(isNaN(failCount) || failCount == null || failCount < 0 ){
                  failCount = 0
                }

                var clockTotal = clocksByLevel[level];

                var clocks = [];

                var offsetIncrement = 1000 + 1000/clockTotal;

                var offset = clockTotal*offsetIncrement;

                while(clockTotal > 0){
                  var skipCount = 1 + Math.floor(
                    Math.random()*countsByLevel[level]*0.2
                  );
                  offset -= offsetIncrement;
                  clocks.push(getNewClockState(level, offset, skipCount))
                  clockTotal--;
                }

                return {
                    "completionDelay":1000,
                    "state":GAME_STATE_NONE,
                    "level":level,
                    "correctCount":0,
                    "lastTimestamp":(new Date()).getTime(),
                    "internalTicks":0,
                    "failCount":failCount,
                    "ticks":0,
                    "clocks":clocks,
                };
            }

            function getNewClockState(level,offset,skipCount){

              var count = countsByLevel[level];

              var states = []

              var indexes = []

              var skips = {};

              for( var i = 0; i < count; i++){
                indexes.push(i)
                states.push(0)
              }

              indexes = shuffle(indexes);

              for(var i = 0; i< skipCount; i++){
                skips[indexes[i]] = true;
              }

              return {
                  "states":states,
                  "currentPosition":0,
                  "tickInterval":1000,
                  "tickOffset":offset,
                  "count":count,
                  "positionOffset":0,
                  "lastSkipPosition":-1,
                  "lastTapPosition":-1,
                  "isComplete":false,
                  "skips":skips,
              }
            }

            function shuffle(array) {
                var currentIndex = array.length, temporaryValue, randomIndex;

                // While there remain elements to shuffle...
                while (0 !== currentIndex) {

                    // Pick a remaining element...
                    randomIndex = Math.floor(Math.random() * currentIndex);
                    currentIndex -= 1;

                    // And swap it with the current element.
                    temporaryValue = array[currentIndex];
                    array[currentIndex] = array[randomIndex];
                    array[randomIndex] = temporaryValue;
                }

                return array;
            }

            function tutorialCount(){
              return 3;
            }
            function tutorialGameState(index){

              var skips = {};

              if(index == 0){
                skips = {2:true};
              }else if(index == 1){
                skips = {2:true};
              }else if(index == 2){
                skips = {};
              }

              return {
                "completionDelay":1000,
                "state":GAME_STATE_NONE,
                "level":0,
                "correctCount":0,
                "lastTimestamp":(new Date()).getTime(),
                "internalTicks":0,
                "failCount":0,
                "ticks":0,
                "clocks":[
                  {
                    "states":[0,0,0,0,0],
                    "currentPosition":0,
                    "tickInterval":1000,
                    "tickOffset":500,
                    "count":5,
                    "positionOffset":0,
                    "lastSkipPosition":-1,
                    "lastTapPosition":-1,
                    "isComplete":false,
                    "skips":skips,
                  }
                ],
              };
            }

            function updateState(state){
                state = incrementTicks(state)
                state = incrementClocks(state)
                return state
            }

            function incrementTicks(state){

              var timestamp = (new Date()).getTime();

              var t = timestamp - state.lastTimestamp; //in milleseconds

              var speed = 1.0; //average speed

              state.ticks = state.ticks + t*speed;

              state.lastTimestamp = (new Date()).getTime();

              return state

            }

            function incrementClocks(state){

                for( var i = 0; i < state.clocks.length; i++ ){

                    var clock = state.clocks[i];

                    var nextPosition = Math.floor((state.ticks - clock.tickOffset)/clock.tickInterval) + clock.positionOffset ;

                    if (!clock.isComplete && clock.currentPosition != nextPosition && nextPosition > 0 ) {

                        if ( 0 <= clock.lastSkipPosition ) {
                            clock.states[(clock.lastSkipPosition - 1)] = 2;
                            state.state = GAME_STATE_COMPLETE
                        }

                        clock.states[nextPosition%clock.count] = 0;

                        if(clock.skips[nextPosition%clock.count]){
                            clock.positionOffset++;
                            nextPosition++;
                            clock.lastSkipPosition = nextPosition;
                            clock.states[nextPosition] = 0;
                        }

                        clock.currentPosition = nextPosition;

                        //we wait an extra position to allow for a tap
                        if(clock.currentPosition >= clock.count + 1){
                          clock.isComplete = true;
                        }

                    }


                }
                return state;

            }

            function updateStateWithTap(state){

                var didFindTappableClock = false;

                for( var i = 0; i < state.clocks.length; i++ ){

                    var clock = state.clocks[i];

                    if ( clock.currentPosition == clock.lastSkipPosition ) {

                        clock.lastSkipPosition = -1;

                        didFindTappableClock = true;
                        state.correctCount++;
                        clock.states[(clock.currentPosition - 1)] = 1;
                    }

                }

                if(!didFindTappableClock){
                    for( var i = 0; i < state.clocks.length; i++ ){
                        var clock = state.clocks[i];
                        clock.states[clock.currentPosition] = 2;
                    }
                    gameState.state = GAME_STATE_COMPLETE
                }

                return state;

            }

            function clear(){
                canvas.innerText = "";
            }

            /************************************************/
            /* EVENT LISTENING                              */
            /************************************************/

            function didTap(listener){
                if(gameState){
                    gameState = updateStateWithTap(gameState);
                }
            }

            function ClickListener(el, letter, completion) {
                this.completion = completion;
                this.element = el;
                this.letter = letter;
                this.element.addEventListener(this.startName, this, false);
                window.addEventListener(this.keydownName, this, false);
            }

            ClickListener.prototype = {

                keydownName:'keydown',
                keyupName:'keyup',
                startName:(('ontouchstart' in document.documentElement)?'touchstart':'mousedown'),
                leaveName:(('ontouchstart' in document.documentElement)?'touchleave':'mouseout'),
                endName:(('ontouchstart' in document.documentElement)?'touchend':'mouseup'),

                isTracking:false,

                handleEvent: function(e) {
                    switch(e.type) {
                        case this.keydownName: this.onKeyStart(e); break;
                        case this.startName: this.onStart(e); break;
                        case this.keyupName: this.onKeyEnd(e); break;
                        case this.leaveName: this.onLeave(e); break;
                        case this.endName: this.onEnd(e); break;
                    }
                },

                onStart: function(e) {

                    e.preventDefault();
                    this.moved = false;

                    this.theTarget = document.elementFromPoint(e.target.clientX, e.target.clientY);
                    if(this.theTarget.nodeType == 3) {
                        this.theTarget = theTarget.parentNode;
                    }

                    this.element.addEventListener(this.leaveName, this, false);
                    this.element.addEventListener(this.endName, this, false);
                },

                onKeyStart: function(e) {
                    var isUnmodified = !e.metaKey && !e.ctrlKey  && !e.altKey;
                    if( isUnmodified ){
                        e.preventDefault();
                        var key = this.stringFromKeyCode(e.keyCode ? e.keyCode : e.which)
                        if(key == this.letter && !this.isTracking){
                            this.isTracking = true;
                            window.addEventListener(this.keyupName, this, false);
                        }
                    }

                },

                onKeyEnd: function(e) {
                    var isUnmodified = !e.metaKey && !e.ctrlKey  && !e.altKey;
                    if( isUnmodified ){
                        e.preventDefault();
                    }
                    if( this.isTracking ){
                        this.isTracking = false;
                        window.removeEventListener(this.keyupName, this, false);
                        if( isUnmodified ){
                            this.completion(this);
                        }
                    }
                },

                onLeave: function(e) {
                    this.element.removeEventListener(this.leaveName, this, false);
                    this.element.removeEventListener(this.endName, this, false);
                    this.theTarget = undefined;
                },

                onEnd: function(e) {
                    this.element.removeEventListener(this.leaveName, this, false);
                    this.element.removeEventListener(this.endName, this, false);

                    this.completion(this);

                    this.theTarget = undefined;
                },

                stringFromKeyCode: function(keyCode) {
                    if ( 65 <= keyCode && keyCode <= 90 ) {
                        return String.fromCharCode(keyCode).toLowerCase();
                    } else if( keyCode == 8 || keyCode == 46 ) {
                        return "del";
                    } else if( keyCode == 32 ){
                        return "space";
                    } else {
                        return "NOT FOUND"
                    }
                }

            };


            /************************************************/
            /* RENDERING                                    */
            /************************************************/

            function render(){

                if( gameState && gameState.state == GAME_STATE_RUNNING) {
                    //we might call game over here
                    gameState = updateState(gameState);
                }

                if(hasCompleteAllClocks(gameState)){
                  gameState.state = GAME_STATE_COMPLETE
                  gameState.completionDelay = 0;
                }


                if( gameState && gameState.state == GAME_STATE_RUNNING) {

                    drawState(gameState);

                    window.requestAnimationFrame(render);

                }else{

                    clear();
                    if( gameState && gameState.state == GAME_STATE_COMPLETE) {
                        //draw the final state of the game
                        drawState(gameState);
                        setTimeout( function(){ didComplete(gameState, metaController) }, gameState.completionDelay);

                    }

                }

            }

            /************************************************/
            /* DRAWING                                      */
            /************************************************/

            function drawState(state){

                if(canvas.childNodes.length != state.clocks.length){
                    while(canvas.childNodes.length < state.clocks.length){
                        canvas.appendChild(document.createElement('div'))
                    }
                    while(canvas.childNodes.length > state.clocks.length){
                        canvas.removeChild(canvas.childNodes[canvas.childNodes.length - 1])
                    }
                }

                var clockColumns = state.clocks.length;
                var clockRows = 1;

                var clockWidth = (100*(1/clockColumns));
                var clockHeight = (100*(1/clockRows));

                for( var i = 0; i < state.clocks.length; i++ ){

                    var clock = state.clocks[i];

                    var clockDiv = canvas.childNodes[i];

                    clockDiv.style.width = clockWidth+"%";
                    clockDiv.style.height = clockHeight+"%";
                    clockDiv.style.left = (i*clockWidth)+"%";

                    var rowHeight = 100/clock.count;

                    var itemHeight = rowHeight*0.90;

                    var itemIndex = clock.currentPosition;
                    var itemYOffset = rowHeight*0.05;

                    while(clockDiv.childNodes.length < clock.count){
                        clockDiv.appendChild(document.createElement('div'));
                    }
                    while(clockDiv.childNodes.length > clock.count){
                        clockDiv.removeChild(clockDiv.childNodes[clockDiv.childNodes.length - 1])
                    }
                    for( var p = 0; p < clock.count; p++ ){
                        var itemDiv = clockDiv.childNodes[p];
                        itemDiv.className = "item";

                        itemDiv.style.left = "1%";
                        itemDiv.style.top = (itemYOffset + p*rowHeight)+"%";
                        itemDiv.style.width = "98%";
                        itemDiv.style.height = itemHeight+"%";

                        if(p == itemIndex && state.state != GAME_STATE_COMPLETE){
                            itemDiv.style.backgroundColor = "#FFD700";
                        }else if(clock.states[p] == 2){
                           itemDiv.style.backgroundColor = "#FF0000";
                        }else if(clock.states[p] == 1){
                            itemDiv.style.backgroundColor = "#00FF00";
                        }else{
                            itemDiv.style.backgroundColor = null;
                        }

                    }

                }

            }

            setupCanvas(isDebug);

            window.addEventListener("load", didLoadHandler,false)

        </script>
    </body>
</html>
